# vfork()와 스택 관리: return vs _exit()의 차이점

## 들어가면서

리눅스 시스템 프로그래밍에서 `vfork()`를 사용할 때 자주 마주치는 질문이 있습니다. "왜 `vfork()` 후에는 `_exit()`을 써야 하고, `return`을 쓰면 안 될까요?" 이 글에서는 스택의 동작 원리부터 시작해서 이 질문에 대한 명확한 답을 찾아보겠습니다.

## vfork()의 특징

### 메모리 공유 메커니즘
`vfork()`는 일반적인 `fork()`와 달리 특별한 특징을 가집니다:

- **메모리 공간 공유**: 부모와 자식 프로세스가 같은 물리적 메모리 공간을 사용
- **부모 프로세스 블록**: 자식이 `exec()` 또는 `_exit()`을 호출할 때까지 부모가 대기
- **Copy-on-Write 미적용**: `fork()`와 달리 메모리 복사가 발생하지 않음

## 스택의 기본 구조 이해

### 스택 포인터(Stack Pointer)란?
스택 포인터는 현재 스택의 "맨 위"를 가리키는 레지스터입니다:

```
높은 주소 ← 스택 시작점
├─────────┤
│  변수 C  │
├─────────┤
│  변수 B  │  ← 스택 포인터(SP)가 여기를 가리킴
├─────────┤
│  변수 A  │
├─────────┤
│    빈    │
│   공간   │
낮은 주소
```

### 스택 프레임(Stack Frame)의 구성
함수가 호출될 때마다 스택에 새로운 프레임이 생성됩니다:

```
├─────────────┤
│ 매개변수     │
├─────────────┤
│ 복귀 주소    │ (함수 종료 시 돌아갈 위치)
├─────────────┤
│ 이전 BP      │ (이전 함수의 베이스 포인터)
├─────────────┤
│ 지역변수들   │ ← 현재 SP 위치
├─────────────┤
```

## vfork() 후 _exit()을 사용하는 이유

### _exit()의 동작 방식
`_exit(0)`이 호출되면:

1. **자식 프로세스만 종료**: 프로세스 자체가 완전히 소멸
2. **메모리 소유권 이전**: 공유하던 메모리의 제어권이 부모에게 완전히 이전
3. **부모 메모리 보존**: 부모가 여전히 실행 중이므로 메모리 영역이 유지됨

### 왜 부모 프로세스의 메모리가 사라지지 않는가?

핵심은 **메모리 소유권의 개념**입니다:

```c
int main() {
    int parent_var = 100;  // 부모의 데이터
    
    if (vfork() == 0) {
        // 자식: 같은 메모리 공간 사용
        _exit(0);  // 자식만 종료, 메모리는 부모에게 온전히 이전
    }
    
    // 부모: 원래 메모리 공간을 계속 사용
    printf("%d\n", parent_var);  // 정상 동작
}
```

## return을 사용하면 안 되는 이유

### return의 실제 동작
`return`은 스택을 제거하는 것이 아니라 **스택 프레임을 정리**합니다:

1. **지역변수 공간 해제**: 현재 함수의 지역변수들이 사용하던 공간을 반납
2. **스택 포인터 조정**: SP를 함수 호출 전 위치로 복원
3. **복귀 주소로 점프**: 호출자 함수로 제어권 반환

### vfork() 상황에서의 문제점

```c
int main() {                    // 부모 SP = 0x1000
    int parent_var = 100;      // 부모 SP = 0x0FFC
    
    if (vfork() == 0) {        // 자식도 SP = 0x0FFC (공유!)
        int child_var = 200;   // 자식 SP = 0x0FF8
        return;                // 문제 발생: SP를 0x1000으로 변경!
    }
    
    // 부모가 깨어남: SP = 0x1000 (변경된 상태)
    printf("%d", parent_var);   // parent_var 위치를 찾을 수 없음!
}
```

**발생하는 문제들:**
- **스택 포인터 불일치**: 자식의 return이 공유하는 스택 포인터를 변경
- **변수 접근 실패**: 부모가 자신의 지역변수 위치를 찾을 수 없음
- **미정의 동작**: 프로그램 크래시 또는 예측 불가능한 결과

## 실제 메모리 레이아웃 분석

### 정상적인 경우 (_exit 사용)
```
자식 _exit() 전: [부모 변수들][자식 데이터] (공유 상태)
자식 _exit() 후: [부모 변수들] (부모만 소유, SP 상태 유지)
```

### 문제가 되는 경우 (return 사용)
```
자식 return 전: [부모 변수들][자식 스택프레임] (SP = 낮은 주소)
자식 return 후: [부모 변수들] (SP = 높은 주소로 변경됨)
부모 깨어남:    변수 위치 불일치로 미정의 동작 발생
```

## 시스템 프로그래밍 Best Practice

### vfork() 사용 시 규칙
1. **절대 return 금지**: 자식 프로세스에서는 절대 return 사용 불가
2. **_exit() 또는 exec() 필수**: 반드시 이 둘 중 하나로만 종료
3. **최소한의 작업**: 자식에서는 exec() 준비 외에는 최소한의 작업만 수행

### 코드 예시
```c
// 올바른 사용법
if (vfork() == 0) {
    execl("/bin/ls", "ls", NULL);  // 또는
    _exit(1);  // exec 실패 시
}

// 잘못된 사용법
if (vfork() == 0) {
    printf("child\n");
    return 0;  // 절대 금지!
}
```

## 결론

`vfork()`에서 `_exit()`을 사용해야 하는 이유는 메모리 소유권과 스택 포인터 관리의 문제입니다. `return`은 스택을 제거하는 것이 아니라 스택 프레임을 정리하면서 스택 포인터를 조정하는데, 이 과정에서 부모와 공유하는 스택 상태가 손상되어 미정의 동작을 초래합니다.

따라서 시스템 프로그래밍에서는 `vfork()` 후 반드시 `_exit()` 또는 `exec()`만을 사용해야 하며, 이는 안전하고 예측 가능한 프로그램 동작을 보장하는 핵심 원칙입니다.